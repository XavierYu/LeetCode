import time
import random


def SwapBits8b(b):
    """
    Swap bits in a bytes
    e.g. 0x5C (0101 1100) will become 0x3A (0011 1010)

    Arguments:
        an 8-bit byte

    Returns:
        byte
    """
    r = 0
    for m1, m2 in (
    (0x80, 0x01), (0x40, 0x02), (0x20, 0x04), (0x10, 0x08), (0x01, 0x80), (0x02, 0x40), (0x04, 0x20), (0x08, 0x10)):
        if b & m1:
            r |= m2
    return r

def WordsToBytes(wordsList, wordLengthInBits=32, littleEndian=1, bitSwap=False):
    """
    It converts 32-bit words to bytes

    Arguments:
        wordsList - words list

    Optional arguments:
        littleEndian - LSB first in a 32bit or 16bit word e.g. 1 => 0x01000000, if not provided then SPILittleEndian parameter from INI file will be used
        bitSwap - bits with a byte will be swapped

    Returns:
        list of bytes
    """
    result = []
    for aWord in wordsList:
        b1 = aWord & 0x000000FF
        b2 = ((aWord & 0x0000FF00) >> 8) & 0xFF
        b3 = ((aWord & 0x00FF0000) >> 16) & 0xFF
        b4 = ((aWord & 0xFF000000) >> 24) & 0xFF

        bytes_in_orginal_order = [b1, b2, b3, b4]
        if wordLengthInBits == 16:
            bytes_in_orginal_order = [b1, b2]
        elif wordLengthInBits == 8:
            bytes_in_orginal_order = [b1]

        if not littleEndian:
            i = len(bytes_in_orginal_order) - 1
        else:
            i = 0
        while True:
            b = bytes_in_orginal_order[i]
            if bitSwap:
                b = SwapBits8b(b)
            result.append(b)
            if not littleEndian:
                i -= 1
                if i < 0:
                    break
            else:
                i += 1
                if i >= len(bytes_in_orginal_order):
                    break
    return result

def BytesListToBinaryString(bytesList):
    """
    It converts a bytes list to a string, each byte is converted to a character
    e.g. input => [65,66,67,32,67]      output => 'ABC C'

    Arguments:
        bytesList

    Returns:
        string
    """
    result = []
    for aByte in bytesList:
        result.append(chr(aByte))
    return ''.join(result)


def BytesListToString(bytesList):
    """
    It converts a bytes list to a string of numbers in hex format
    e.g. input => [65,66,67,32,67]      output => '0x41 0x42 0x43 0x20 0x43'

    Arguments:
        bytesList

    Returns:
        string
    """
    result = ''
    for aByte in bytesList:
        result += '0x%X ' % aByte
    result = result[:-1]
    return result

def CalculateCRC16(bytesList=None, binaryString=None):
    """
    CRC16 polynomial: 0x18005, bit reverse algorithm
    """
    table = [0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500,
             0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1,
             0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81,
             0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540,
             0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001,
             0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0,
             0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80,
             0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
             0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700,
             0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0,
             0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480,
             0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41,
             0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01,
             0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1,
             0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181,
             0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
             0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901,
             0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1,
             0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680,
             0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040]

    if bytesList:
        pass
    elif binaryString:
        bytesList = map(ord, binaryString)
    else:
        raise RuntimeError("either bytesList or binaryString must be provided")

    crc = 0
    for abyte in bytesList:
        crc = table[abyte ^ (crc & 0xFF)] ^ (crc >> 8)

    return crc

input1 =  BytesListToBinaryString([0x22,0,0,0x08,0,0])
input2 =  BytesListToBinaryString([0x00,0x00,0x00,0x08,0x00])
print (input1, input2)
ret1 = CalculateCRC16([0x00,0x00,0x00,0x08,0x00,0x00])
print ret1
print hex(ret1)
ret2 = CalculateCRC16([0x00,0x00,0x00,0x08,0x00])
print ret2
print hex(ret2)


fileread = open("D:\\SVN_DVT\\04_13_00_rc01\\FG1258143v2-04_13_00_rc01_Current.wf", 'rb')

byte1 = fileread.read(0x64)


ret = []
for char in byte1:
    ret.append(ord(char))
#print BytesListToString(ret)
finalByteList = [0xD,0x0,0x64]+ret
finalstr = BytesListToString(finalByteList)

print finalstr

tempcrc = CalculateCRC16(finalByteList)
print hex(tempcrc)


print WordsToBytes(wordsList = [0x1164], littleEndian = 0, wordLengthInBits = 16)

tempcrc = CalculateCRC16([0x21,0x00,0x00])
print hex(tempcrc)

print "\x22\x00\x00\x0a\xa0"